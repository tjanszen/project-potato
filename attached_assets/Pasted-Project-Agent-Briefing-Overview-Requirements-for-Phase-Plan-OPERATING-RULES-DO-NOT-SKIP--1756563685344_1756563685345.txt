Project 🥔 — Agent Briefing (Overview + Requirements for Phase Plan)

OPERATING RULES (DO NOT SKIP)
- Phase-gated: First deliver a PHASED PLAN only; stop until I approve Phase 0. No code before approval.
- Everything ships behind a feature flag. Primary flag: ff.potato.no_drink_v1 (default OFF).
- Evidence-first: Every phase must have exit criteria + exact commands/SQL/log checks + an evidence template.
- Prefer the bundled “GPT Kit” if provided; otherwise proceed with the details below.

PROJECT OVERVIEW
Build a very simple tracking web app where users mark calendar days as “No Drink”. Start minimal but keep the data model flexible for future “Did Drink” (false) and streaks/badges.

TOP-LEVEL NON-GOALS (v1)
- No streak totals, badges, or points.
- No settings page or extra sections (dashboard only).
- No Google OAuth (use email+password auth instead).
- No marking future dates other than “today”.
- No bulk marking / drag to select.
- No accessibility work (ARIA/keyboard) for v1.
- No public profiles, data export/delete.

PRODUCT & UX
- Dashboard shows a calendar. Users can scroll months within 2025 only. Don’t show any month before 2025-01-01.
- Future days: disabled, except “today” which is allowed.
- Past range: users can mark any day back to 2025-01-01 (fixed cutoff).
- Interaction: clicking a day opens a drawer.
  - Drawer shows month/day and a single CTA: [No Drink].
  - On click, the day is saved/marked as true (“No Drink”).
  - Visual: marked days show a subtle filled dot + color.
  - Show a small “last updated” timestamp in the drawer.
  - Toast on save success/failure.
- Idempotency: clicking [No Drink] again on an already-true day is a no-op (no duplicates).
- Undo/Clear: NOT available in the UI for v1.

DATA MODEL & SEMANTICS
- Day semantics: store as date (YYYY-MM-DD), independent of time.
- Timezone of “day”: use the user’s timezone (user-level setting); derive user_local_date from that.
- Truth table: value=true means “No Drink”; absence = unknown (do not store false in v1).
- Event log + state table:
  1) click_events (append-only) for every user action.
  2) day_marks (deduped current state, unique by user_id+date).
- Uniqueness: enforce UNIQUE (user_id, date) on day_marks.
- Backdating window: enforce server-side that date ∈ [2025-01-01, today in user tz].
- Future: when value=false (“Did Drink”) arrives later, last-write-wins.

RECOMMENDED SCHEMA (Postgres, UUID v4)
- users
  - id UUID PK
  - email TEXT UNIQUE NOT NULL
  - password_hash TEXT NOT NULL
  - timezone TEXT NOT NULL  -- e.g., "America/New_York"
  - created_at TIMESTAMPTZ NOT NULL DEFAULT now()
- day_marks
  - user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE
  - date DATE NOT NULL
  - value BOOLEAN NOT NULL CHECK (value = TRUE)  -- v1 only stores TRUE
  - updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
  - PRIMARY KEY (user_id, date)  -- or UNIQUE + surrogate PK
  - CHECK (date >= DATE '2025-01-01')
- click_events
  - click_id UUID PK DEFAULT gen_random_uuid()
  - user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE
  - date DATE NOT NULL
  - value BOOLEAN
