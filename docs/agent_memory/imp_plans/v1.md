# Implementation Plan v1 - Potato No Drink Tracker

## Overview
Phase-gated development plan for building a simple habit tracking web app where users mark calendar days as "No Drink". All features ship behind feature flag `ff.potato.no_drink_v1` (default OFF).

---

## PHASE 0: Foundation & Database Setup âœ… COMPLETE
- **Goal:** Establish core infrastructure with PostgreSQL schema, basic Express server, and feature flag framework
- **Tasks:**
  - Set up Express.js server with CORS and basic middleware âœ…
  - Configure PostgreSQL connection and create database schema âœ…
  - Implement feature flag system with ff.potato.no_drink_v1 (default OFF) âœ…
  - Create basic health check endpoint âœ…
  - Set up environment configuration âœ…
- **Risks/Assumptions:**
  - PostgreSQL service availability in deployment environment âœ…
  - Feature flag system correctly gates all functionality âœ…
- **Exit Criteria (objective, testable):**
  - Server starts successfully on configured port âœ…
  - Database connection established and schema created âœ…
  - Feature flag returns correct default state (OFF) âœ…
  - Health check endpoint returns 200 status âœ…
- **Evidence to Collect:**
  ```sql
  SELECT table_name FROM information_schema.tables WHERE table_schema = 'public';
  SELECT column_name, data_type FROM information_schema.columns WHERE table_name = 'users';
  ```
  ```bash
  curl http://localhost:3000/health
  curl http://localhost:3000/api/feature-flags/ff.potato.no_drink_v1
  ```
- **Rollback Plan:** Remove database tables, stop server process
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + server-wide scope
- **Status:** âœ… COMPLETE

---

## PHASE 1: Authentication System
- **Goal:** Implement email/password authentication with user registration and login
- **Tasks:**
  - Create user registration endpoint (POST /api/auth/signup)
  - Create user login endpoint (POST /api/auth/login)
  - Implement password hashing with bcrypt
  - Set up session management
  - Create user profile endpoint (GET /api/me)
  - Add timezone field to user model
- **Risks/Assumptions:**
  - Session storage mechanism works reliably
  - Password hashing performance acceptable
  - Email uniqueness properly enforced
- **Exit Criteria (objective, testable):**
  - User can register with email/password
  - User can login with valid credentials
  - Invalid credentials return 401 error
  - Session persists across requests
  - User timezone stored and retrieved correctly
- **Evidence to Collect:**
  ```bash
  curl -X POST http://localhost:3000/api/auth/signup -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"test123","timezone":"America/New_York"}'
  curl -X POST http://localhost:3000/api/auth/login -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"test123"}'
  ```
  ```sql
  SELECT email, timezone, created_at FROM users WHERE email = 'test@example.com';
  ```
- **Rollback Plan:** Disable auth endpoints, clear user sessions
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + auth endpoints gated

---

## PHASE 2: Calendar API & Data Model
- **Goal:** Implement calendar data retrieval and day marking functionality with proper timezone handling
- **Tasks:**
  - Create calendar endpoint (GET /api/calendar?month=2025-06)
  - Implement day marking endpoint (POST /api/days/:yyyy-mm-dd/no-drink)
  - Add timezone-aware date validation (2025-01-01 to today)
  - Implement idempotent marking logic
  - Create event logging for click_events table
  - Add unique constraint enforcement on day_marks
- **Risks/Assumptions:**
  - Timezone calculations work correctly across different user timezones
  - Database constraints prevent duplicate entries
  - Date range validation covers edge cases
- **Exit Criteria (objective, testable):**
  - Calendar API returns correct month data with marked days
  - Day marking creates day_marks entry and click_events log
  - Duplicate marking attempts are no-ops (no duplicate day_marks)
  - Date validation rejects dates before 2025-01-01 or future dates (except today)
  - Timezone-aware "today" calculation works correctly
- **Evidence to Collect:**
  ```bash
  curl -H "Cookie: session_id=..." http://localhost:3000/api/calendar?month=2025-06
  curl -X POST -H "Cookie: session_id=..." http://localhost:3000/api/days/2025-06-15/no-drink
  ```
  ```sql
  SELECT user_id, date, value, updated_at FROM day_marks WHERE user_id = '...';
  SELECT user_id, date, created_at FROM click_events WHERE user_id = '...';
  SELECT COUNT(*) FROM day_marks WHERE user_id = '...' AND date = '2025-06-15';
  ```
- **Rollback Plan:** Disable calendar and marking endpoints, clear test data
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + calendar API gated

---

## PHASE 3: React Frontend & Calendar UI
- **Goal:** Build React frontend with calendar grid, day drawer, and basic user interface
- **Tasks:**
  - Set up React + Vite project structure
  - Create CalendarGrid component with month navigation
  - Implement DayCell component with click handlers
  - Build DayDrawer component with "No Drink" button
  - Add visual indicators for marked days (dots + color)
  - Implement month restriction (2025 only)
  - Add future date disabling (except today)
- **Risks/Assumptions:**
  - Calendar grid renders correctly across different screen sizes
  - Date calculations match backend timezone logic
  - User interactions feel responsive
- **Exit Criteria (objective, testable):**
  - Calendar displays current month with proper navigation
  - Clicking a day opens drawer with correct date
  - Marked days show visual indicators
  - Future dates (except today) are disabled
  - Month navigation restricted to 2025
- **Evidence to Collect:**
  ```bash
  npm run build
  curl http://localhost:3000/ # Should serve React app
  # Browser testing: verify calendar renders, day clicking works
  ```
  - Manual testing: click various dates, verify drawer opens
  - Visual inspection: marked days show dots/color
- **Rollback Plan:** Serve static placeholder page instead of React app
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + frontend feature gated

---

## PHASE 4: Integration & User Experience
- **Goal:** Connect frontend to backend APIs, implement toast notifications, and complete user flow
- **Tasks:**
  - Integrate authentication flow in React
  - Connect calendar component to GET /api/calendar
  - Implement day marking with POST /api/days/:date/no-drink
  - Add toast notifications for success/failure
  - Display last updated timestamp in drawer
  - Add loading states and error handling
  - Implement client-side debouncing
- **Risks/Assumptions:**
  - API integration works seamlessly
  - Error states are handled gracefully
  - User experience feels polished
- **Exit Criteria (objective, testable):**
  - User can complete full flow: register â†’ login â†’ mark days â†’ see visual feedback
  - Toast notifications appear on save success/failure
  - Loading states display during API calls
  - Error conditions show appropriate messages
  - Day marking is debounced to prevent rapid clicks
- **Evidence to Collect:**
  - End-to-end user flow testing
  - Network tab shows correct API calls
  - Database verification of marked days
  ```sql
  SELECT u.email, dm.date, dm.value, dm.updated_at 
  FROM users u JOIN day_marks dm ON u.id = dm.user_id 
  WHERE u.email = 'test@example.com';
  ```
- **Rollback Plan:** Disable frontend API integration, show static calendar
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + complete feature gated

---

## PHASE 5: Production Readiness & Feature Flag Activation
- **Goal:** Prepare for production deployment and enable feature flag for user access
- **Tasks:**
  - Add production environment configuration
  - Implement proper error logging and monitoring
  - Add basic security headers and rate limiting
  - Verify all database constraints and indexes
  - Test feature flag toggle functionality
  - Prepare feature flag activation plan
- **Risks/Assumptions:**
  - Production environment matches development setup
  - Feature flag toggle works without service restart
  - Security measures don't break user experience
- **Exit Criteria (objective, testable):**
  - Application runs stable in production environment
  - Feature flag can be toggled ON/OFF without issues
  - Security headers present in HTTP responses
  - Error logging captures issues appropriately
  - Rate limiting prevents abuse
- **Evidence to Collect:**
  ```bash
  curl -I http://production-url.com/ # Check security headers
  # Toggle feature flag ON, verify app accessible
  # Toggle feature flag OFF, verify app hidden
  ```
  - Monitor logs for errors during flag toggle
  - Verify database performance under expected load
- **Rollback Plan:** Set feature flag to OFF, rollback to previous stable version
- **Feature Flag(s):** ff.potato.no_drink_v1 + toggle to ON + production activation

---

## Current Status
- **Phase 0:** âœ… COMPLETE
- **Phase 1:** ðŸ”„ READY TO START (awaiting approval)
- **Phases 2-5:** ðŸ“‹ PLANNED

## Key Principles
- All functionality gated behind ff.potato.no_drink_v1 feature flag
- Evidence-first approach with testable exit criteria
- Phase-gated development requiring explicit approval
- Rollback plans for every phase
- Production-ready architecture from Phase 0