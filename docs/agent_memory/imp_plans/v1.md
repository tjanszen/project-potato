# Implementation Plan v1 - Potato No Drink Tracker

## Overview
Phase-gated development plan for building a simple habit tracking web app where users mark calendar days as "No Drink". All features ship behind feature flag `ff.potato.no_drink_v1` (default OFF).

---

## PHASE 0: Foundation & Database Setup ‚úÖ COMPLETE
- **Goal:** Establish core infrastructure with PostgreSQL schema, basic Express server, and feature flag framework
- **Tasks:**
  - Set up Express.js server with CORS and basic middleware ‚úÖ
  - Configure PostgreSQL connection and create database schema ‚úÖ
  - Implement feature flag system with ff.potato.no_drink_v1 (default OFF) ‚úÖ
  - Create basic health check endpoint ‚úÖ
  - Set up environment configuration ‚úÖ
- **Risks/Assumptions:**
  - PostgreSQL service availability in deployment environment ‚úÖ
  - Feature flag system correctly gates all functionality ‚úÖ
- **Exit Criteria (objective, testable):**
  - Server starts successfully on configured port ‚úÖ
  - Database connection established and schema created ‚úÖ
  - Feature flag returns correct default state (OFF) ‚úÖ
  - Health check endpoint returns 200 status ‚úÖ
  - **UPDATED:** Deployment configuration validated (start scripts, port binding, production readiness) ‚ö†Ô∏è
- **Evidence to Collect:**
  ```sql
  SELECT table_name FROM information_schema.tables WHERE table_schema = 'public';
  SELECT column_name, data_type FROM information_schema.columns WHERE table_name = 'users';
  ```
  ```bash
  curl http://localhost:3000/health
  curl http://localhost:3000/api/feature-flags/ff.potato.no_drink_v1
  ```
- **Rollback Plan:** Remove database tables, stop server process
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + server-wide scope
- **Status:** ‚ö†Ô∏è NEEDS DEPLOYMENT FIX (see bugs journal 2025-09-01)

---

## PHASE 1A: User Model & Registration
- **Goal:** Extend user schema and implement secure user registration
- **Tasks:**
  - Add timezone field to user model in shared/schema.ts
  - Push schema changes to database (npm run db:push)
  - Create user registration endpoint (POST /api/auth/signup)
  - Implement password hashing with bcrypt
  - Add email uniqueness validation
- **Risks/Assumptions:**
  - Database schema migration succeeds without data loss
  - Password hashing performance acceptable
  - Email uniqueness properly enforced by database constraints
- **Exit Criteria (objective, testable):**
  - User can register with email/password/timezone
  - Passwords are hashed (not stored in plaintext)
  - Duplicate emails return 400 error
  - Timezone field is stored correctly
- **Evidence to Collect:**
  ```bash
  curl -X POST http://localhost:3000/api/auth/signup -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"test123","timezone":"America/New_York"}'
  ```
  ```sql
  SELECT email, timezone, password_hash, created_at FROM users WHERE email = 'test@example.com';
  # Verify password_hash != 'test123' (is hashed)
  ```
- **Rollback Plan:** Disable signup endpoint, revert schema changes if needed
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + signup endpoint gated

---

## PHASE 1B: Minimal Frontend for Auth Testing
- **Goal:** Build a simple React UI to test the signup API (Phase 1A)
- üìÅ **Code lives in /client/** ‚Äî helps future devs know where to find the test UI
- **Tasks:**
  - Create a Vite+React frontend in /client
  - Add signup form with email, password, timezone
  - Submit form to POST /api/auth/signup
  - Show success and error messages
  - Include optional toggle for feature flag ff.potato.no_drink_v1
  - Add basic client-side validation
- **Preconditions:**
  - Backend CORS must allow dev client origin (e.g., http://localhost:5173)
- **Risks/Assumptions:**
  - Form is unstyled and dev-only
- **Exit Criteria (objective, testable):**
  - Form submits to POST /api/auth/signup and creates user in DB
  - Form must block invalid input client-side before submission
  - Valid inputs return success message
  - Invalid inputs return error messages
  - Manual test confirms DB entry created
- **Evidence to Collect:**
  - Browser test of form submission
  - Dev tools console logs from POST /api/auth/signup
  - SQL check:
    ```sql
    SELECT email, timezone FROM users ORDER BY created_at DESC LIMIT 1;
    ```
- **Rollback Plan:** Disable frontend dev server, remove test form
- **Feature Flag(s):** None (UI is dev-only)

---

## PHASE 1C: Authentication & Sessions
- **Goal:** Implement secure login with session management
- **Tasks:**
  - Create user login endpoint (POST /api/auth/login)
  - Set up session management with express-session default storage
  - Configure secure session cookies: `HttpOnly`, `Secure`, and `SameSite=Strict` flags
  - Implement session ID regeneration on successful login to prevent fixation
  - Add password verification against hashed passwords
- **Risks/Assumptions:**
  - Session storage mechanism works reliably
  - Session fixation or insecure cookies if security flags are not set correctly
  - Password comparison works correctly with bcrypt
- **Exit Criteria (objective, testable):**
  - User can login with valid credentials
  - Invalid credentials return 401 error
  - Session persists across requests
  - Session cookie includes all security flags (HttpOnly, Secure, SameSite=Strict)
  - Session ID changes after successful login
- **Evidence to Collect:**
  ```bash
  curl -i -X POST http://localhost:3000/api/auth/login -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"test123"}'
  # Verify Set-Cookie includes: HttpOnly; Secure; SameSite=Strict
  curl -X POST http://localhost:3000/api/auth/login -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"wrong"}'
  # Should return 401
  ```
- **Rollback Plan:** Disable login endpoint, clear active user sessions
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + login endpoint gated

---

## PHASE 1D: User Profile & Integration
- **Goal:** Complete authentication flow with user profile access
- **Tasks:**
  - Create user profile endpoint (GET /api/me)
  - Add session-based authentication middleware
  - Implement session validation for protected routes
  - Test complete registration ‚Üí login ‚Üí profile access flow
- **Risks/Assumptions:**
  - Session middleware correctly identifies authenticated users
  - Profile data retrieval performs adequately
- **Exit Criteria (objective, testable):**
  - Authenticated users can access profile data
  - Unauthenticated requests to /api/me return 401
  - Profile returns correct user data (email, timezone, created_at)
  - Complete auth flow works end-to-end
- **Evidence to Collect:**
  ```bash
  # Complete flow test
  curl -X POST http://localhost:3000/api/auth/signup -H "Content-Type: application/json" -d '{"email":"flow@test.com","password":"test123","timezone":"America/New_York"}'
  curl -c cookies.txt -X POST http://localhost:3000/api/auth/login -H "Content-Type: application/json" -d '{"email":"flow@test.com","password":"test123"}'
  curl -b cookies.txt http://localhost:3000/api/me
  curl http://localhost:3000/api/me  # Should return 401
  ```
  ```sql
  SELECT email, timezone, created_at FROM users WHERE email = 'flow@test.com';
  ```
- **Rollback Plan:** Disable profile endpoint, revert authentication middleware
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + profile endpoint gated

---

## PHASE 2A: Calendar Retrieval API
- **Goal:** Implement calendar data retrieval with proper month filtering and user authentication
- **Tasks:**
  - Create calendar endpoint (GET /api/calendar?month=2025-06)
  - Add authentication middleware to protect calendar endpoint
  - Implement month-based day_marks retrieval from database
  - Return JSON format with date array and marked status
  - Add basic input validation for month parameter format
- **Risks/Assumptions:**
  - Calendar query performance acceptable with user-based filtering
  - Month parameter format correctly validated (YYYY-MM)
  - Authentication middleware correctly identifies users
- **Exit Criteria (objective, testable):**
  - Calendar API requires valid authentication (returns 401 if not logged in)
  - Calendar API returns correct month data structure
  - API correctly filters day_marks by authenticated user
  - Month parameter validation rejects invalid formats
- **Evidence to Collect:**
  ```bash
  curl -b cookies.txt http://localhost:3000/api/calendar?month=2025-06
  curl http://localhost:3000/api/calendar?month=2025-06  # Should return 401
  curl -b cookies.txt http://localhost:3000/api/calendar?month=invalid  # Should return 400
  ```
  ```sql
  SELECT user_id, date, value, updated_at FROM day_marks WHERE user_id = 'test-user-id';
  ```
- **Rollback Plan:** Disable calendar endpoint, revert authentication requirements
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + calendar endpoint gated

---

## PHASE 2B: Day Marking API
- **Goal:** Implement day marking endpoint with basic database persistence
- **Tasks:**
  - Create day marking endpoint (POST /api/days/:yyyy-mm-dd/no-drink)
  - Add date parameter parsing and basic validation
  - Implement day_marks table insertion with user_id
  - Add authentication middleware to protect marking endpoint
  - Return success/error responses with appropriate status codes
- **Risks/Assumptions:**
  - Date parsing works correctly for various input formats
  - Database insertion handles user_id association properly
  - API response format meets client expectations
- **Exit Criteria (objective, testable):**
  - Day marking API requires valid authentication (returns 401 if not logged in)
  - Valid date marking creates entry in day_marks table
  - API returns success response with created data
  - Invalid date format returns 400 error
- **Evidence to Collect:**
  ```bash
  curl -X POST -b cookies.txt http://localhost:3000/api/days/2025-06-15/no-drink
  curl -X POST http://localhost:3000/api/days/2025-06-15/no-drink  # Should return 401
  curl -X POST -b cookies.txt http://localhost:3000/api/days/invalid-date/no-drink  # Should return 400
  ```
  ```sql
  SELECT user_id, date, value, created_at FROM day_marks WHERE date = '2025-06-15';
  ```
- **Rollback Plan:** Disable day marking endpoint, remove test day_marks entries
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + day marking endpoint gated

---

## PHASE 2C: Timezone-Aware Validation
- **Goal:** Implement proper timezone-aware date validation and "today" calculation
- **Tasks:**
  - Add timezone-aware date validation (2025-01-01 to today in user's timezone)
  - Implement user timezone retrieval from database
  - Create date boundary validation logic
  - Add "today" calculation based on user's timezone
  - Reject future dates except "today" in user's timezone
- **Risks/Assumptions:**
  - Timezone calculations work correctly across different user timezones
  - Date boundary validation covers edge cases (leap years, month boundaries)
  - User timezone data is always available and valid
- **Exit Criteria (objective, testable):**
  - Date validation rejects dates before 2025-01-01 in user's timezone
  - Date validation rejects future dates (except today) in user's timezone
  - "Today" calculation works correctly for different user timezones
  - Validation errors return appropriate error messages
- **Evidence to Collect:**
  ```bash
  # Test with user in America/New_York timezone
  curl -X POST -b cookies.txt http://localhost:3000/api/days/2024-12-31/no-drink  # Should reject
  curl -X POST -b cookies.txt http://localhost:3000/api/days/2025-12-31/no-drink  # Should reject if future
  curl -X POST -b cookies.txt http://localhost:3000/api/days/$(date +%Y-%m-%d)/no-drink  # Should work
  ```
  ```sql
  SELECT email, timezone FROM users WHERE id = 'test-user-id';
  ```
- **Rollback Plan:** Disable timezone validation, use simple date checks
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + timezone validation gated

---

## PHASE 2D: Idempotency & Constraints
- **Goal:** Implement idempotent day marking with proper database constraints
- **Tasks:**
  - Add unique constraint on (user_id, date) in day_marks table
  - Implement ON CONFLICT DO UPDATE logic for idempotent marking
  - Handle duplicate marking attempts gracefully (return existing record)
  - Add database constraint enforcement
  - Test edge cases for concurrent marking attempts
- **Risks/Assumptions:**
  - Database constraints prevent duplicate entries reliably
  - ON CONFLICT logic works correctly with PostgreSQL
  - Concurrent requests don't cause race conditions
- **Exit Criteria (objective, testable):**
  - Multiple marking attempts for same day are no-ops (no duplicate day_marks)
  - Database enforces unique constraint on (user_id, date)
  - Duplicate attempts return success with existing data
  - Concurrent marking attempts handled gracefully
- **Evidence to Collect:**
  ```bash
  # Mark same day multiple times
  curl -X POST -b cookies.txt http://localhost:3000/api/days/2025-06-15/no-drink
  curl -X POST -b cookies.txt http://localhost:3000/api/days/2025-06-15/no-drink
  curl -X POST -b cookies.txt http://localhost:3000/api/days/2025-06-15/no-drink
  ```
  ```sql
  SELECT COUNT(*) as count FROM day_marks WHERE user_id = 'test-user-id' AND date = '2025-06-15';
  -- Should return count = 1
  ```
- **Rollback Plan:** Remove unique constraints, allow duplicate entries temporarily
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + idempotency constraints gated

---

## PHASE 2E: Event Logging
- **Goal:** Implement comprehensive event logging for audit trail and analytics
- **Tasks:**
  - Create event logging for click_events table on every marking attempt
  - Log both successful and duplicate marking attempts
  - Add timestamp and user context to event logs
  - Implement event logging middleware
  - Add event retrieval for debugging/analytics
- **Risks/Assumptions:**
  - Event logging doesn't significantly impact performance
  - click_events table handles high volume appropriately
  - Event data provides useful audit trail
- **Exit Criteria (objective, testable):**
  - Every day marking attempt creates entry in click_events table
  - Event logs include user_id, date, timestamp, and action type
  - Both successful and duplicate attempts are logged
  - Event logging doesn't block day marking on failure
- **Evidence to Collect:**
  ```bash
  # Make several marking attempts
  curl -X POST -b cookies.txt http://localhost:3000/api/days/2025-06-15/no-drink
  curl -X POST -b cookies.txt http://localhost:3000/api/days/2025-06-16/no-drink
  ```
  ```sql
  SELECT user_id, date, action, created_at FROM click_events WHERE user_id = 'test-user-id' ORDER BY created_at DESC;
  SELECT COUNT(*) as event_count FROM click_events WHERE user_id = 'test-user-id';
  SELECT COUNT(*) as mark_count FROM day_marks WHERE user_id = 'test-user-id';
  ```
- **Rollback Plan:** Disable event logging, clear test click_events entries
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + event logging gated

---

## PHASE 3A: Frontend Project Setup
- **Goal:** Set up React + Vite frontend infrastructure with proper development workflow
- **Tasks:**
  - Set up React + Vite project structure in /client directory
  - Configure TypeScript and essential development dependencies
  - Set up routing with wouter for single-page navigation
  - Configure API client with proper CORS and authentication
  - Add development scripts and build configuration
  - Implement basic error boundaries and loading states
- **Risks/Assumptions:**
  - Vite build configuration works with existing Express server
  - TypeScript compilation succeeds without conflicts
  - Development server integrates properly with backend APIs
- **Exit Criteria (objective, testable):**
  - Frontend project builds successfully with npm run build
  - Development server starts without errors
  - API client can connect to backend endpoints
  - TypeScript compilation passes without errors
  - Basic routing navigation works
- **Evidence to Collect:**
  ```bash
  cd /client && npm run build
  cd /client && npm run dev  # Should start on port 5173
  curl http://localhost:5173/  # Should serve React app
  # Browser test: verify app loads without console errors
  ```
  - Network tab shows successful API connection attempts
  - TypeScript compiler shows no errors
- **Rollback Plan:** Serve static HTML page, disable React frontend
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + frontend project gated

---

## PHASE 3B: Calendar Grid & Navigation
- **Goal:** Create monthly calendar grid component with month-to-month navigation
- **Tasks:**
  - Build CalendarGrid component with 7x6 grid layout
  - Implement month header with current month/year display
  - Add previous/next month navigation buttons
  - Create date calculation logic for proper calendar layout
  - Add month restriction to 2025 only (disable other years)
  - Style calendar grid for responsive design
- **Risks/Assumptions:**
  - Date calculations work correctly across month boundaries
  - Calendar layout renders properly on different screen sizes
  - Month restriction logic prevents navigation outside 2025
- **Exit Criteria (objective, testable):**
  - Calendar displays current month with correct date layout
  - Previous/next buttons navigate between months correctly
  - Navigation is restricted to 2025 (Jan-Dec only)
  - Calendar grid is responsive and visually formatted
  - Date cells display correct day numbers
- **Evidence to Collect:**
  ```bash
  # Browser testing required
  # Navigate to January 2025, verify no previous month button
  # Navigate to December 2025, verify no next month button
  # Test calendar grid on mobile and desktop viewports
  ```
  - Manual testing: verify month navigation boundaries
  - Visual inspection: calendar grid layout and responsiveness
  - Console verification: no date calculation errors
- **Rollback Plan:** Show static calendar placeholder, disable navigation
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + calendar grid gated

---

## PHASE 3C: DayCell Component & Interaction
- **Goal:** Implement individual day cells with click handlers and date selection
- **Tasks:**
  - Create DayCell component for individual calendar dates
  - Add click handlers for day selection
  - Implement date state management (selected day)
  - Add hover effects and interactive feedback
  - Handle edge cases (empty cells, month boundaries)
  - Pass selected date to parent components
- **Risks/Assumptions:**
  - Click handlers respond quickly without lag
  - Date selection state management works correctly
  - Component re-renders efficiently on state changes
- **Exit Criteria (objective, testable):**
  - Clicking a day cell selects that date
  - Selected date is properly stored in component state
  - Hover effects provide visual feedback
  - Empty cells (outside current month) are non-interactive
  - Date selection triggers parent component updates
- **Evidence to Collect:**
  ```bash
  # Browser testing required - no curl equivalent
  # Click various dates, verify selection state changes
  # Test hover effects on interactive cells
  # Verify empty cells don't respond to clicks
  ```
  - Manual testing: click different dates, verify selection
  - Developer tools: verify state updates in React DevTools
  - Visual inspection: hover and selection styling
- **Rollback Plan:** Disable click handlers, show static calendar cells
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + day selection gated

---

## PHASE 3D: DayDrawer & "No Drink" Button
- **Goal:** Build sliding drawer component with day marking functionality
- **Tasks:**
  - Create DayDrawer component with slide-in animation
  - Display selected date in drawer header
  - Add "No Drink" button with click handler
  - Implement drawer open/close functionality
  - Connect drawer to day marking API (POST /api/days/:date/no-drink)
  - Add loading states and success/error feedback
- **Risks/Assumptions:**
  - Drawer animation performs smoothly
  - API integration works reliably
  - User feedback mechanisms are clear
- **Exit Criteria (objective, testable):**
  - Drawer opens when day is selected
  - Drawer displays correct selected date
  - "No Drink" button sends API request
  - API success/failure shows appropriate feedback
  - Drawer can be closed by user interaction
- **Evidence to Collect:**
  ```bash
  # API testing can be verified with network tab
  # POST /api/days/2025-06-15/no-drink should be sent
  ```
  - Manual testing: open drawer, click "No Drink" button
  - Network tab: verify API calls are made correctly
  - Database verification: marked days appear in database
  ```sql
  SELECT date, value, updated_at FROM day_marks WHERE user_id = 'test-user-id' ORDER BY updated_at DESC;
  ```
- **Rollback Plan:** Disable drawer functionality, show marking status inline
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + day marking drawer gated

---

## PHASE 3E: Visual Indicators & Restrictions
- **Goal:** Add visual feedback for marked days and enforce date restrictions
- **Tasks:**
  - Add visual indicators (dots/colors) for marked days
  - Implement future date disabling (except today in user timezone)
  - Style disabled dates with different appearance
  - Connect visual indicators to calendar API data
  - Add loading states for calendar data fetching
  - Implement refresh functionality to update indicators
- **Risks/Assumptions:**
  - Visual indicators are clearly visible and intuitive
  - Date restrictions match backend timezone logic exactly
  - Calendar data loading doesn't impact user experience
- **Exit Criteria (objective, testable):**
  - Marked days display visual indicators (dots, colors)
  - Future dates (except today) are visually disabled and non-clickable
  - Calendar loads marked days from API on page load
  - Visual indicators update immediately after marking
  - Date restrictions match user's timezone settings
- **Evidence to Collect:**
  ```bash
  # GET /api/calendar?month=2025-06 should return marked dates
  curl -b cookies.txt http://localhost:3000/api/calendar?month=2025-06
  ```
  - Manual testing: verify marked days show indicators
  - Visual inspection: disabled future dates appear different
  - API verification: calendar loads existing marked days
  - Timezone testing: verify today calculation matches user timezone
  ```sql
  SELECT date, value FROM day_marks WHERE user_id = 'test-user-id';
  ```
- **Rollback Plan:** Remove visual indicators, disable date restrictions
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + visual indicators gated

---

## PHASE 4: Integration & User Experience
- **Goal:** Connect frontend to backend APIs, implement toast notifications, and complete user flow
- **Tasks:**
  - Integrate authentication flow in React
  - Connect calendar component to GET /api/calendar
  - Implement day marking with POST /api/days/:date/no-drink
  - Add toast notifications for success/failure
  - Display last updated timestamp in drawer
  - Add loading states and error handling
  - Implement client-side debouncing
- **Risks/Assumptions:**
  - API integration works seamlessly
  - Error states are handled gracefully
  - User experience feels polished
- **Exit Criteria (objective, testable):**
  - User can complete full flow: register ‚Üí login ‚Üí mark days ‚Üí see visual feedback
  - Toast notifications appear on save success/failure
  - Loading states display during API calls
  - Error conditions show appropriate messages
  - Day marking is debounced to prevent rapid clicks
- **Evidence to Collect:**
  - End-to-end user flow testing
  - Network tab shows correct API calls
  - Database verification of marked days
  ```sql
  SELECT u.email, dm.date, dm.value, dm.updated_at 
  FROM users u JOIN day_marks dm ON u.id = dm.user_id 
  WHERE u.email = 'test@example.com';
  ```
- **Rollback Plan:** Disable frontend API integration, show static calendar
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + complete feature gated

---

## PHASE 5: Production Readiness & Feature Flag Activation
- **Goal:** Prepare for production deployment and enable feature flag for user access
- **Tasks:**
  - Add production environment configuration
  - Implement proper error logging and monitoring
  - Add basic security headers and rate limiting
  - Verify all database constraints and indexes
  - Test feature flag toggle functionality
  - Prepare feature flag activation plan
- **Risks/Assumptions:**
  - Production environment matches development setup
  - Feature flag toggle works without service restart
  - Security measures don't break user experience
- **Exit Criteria (objective, testable):**
  - Application runs stable in production environment
  - Feature flag can be toggled ON/OFF without issues
  - Security headers present in HTTP responses
  - Error logging captures issues appropriately
  - Rate limiting prevents abuse
- **Evidence to Collect:**
  ```bash
  curl -I http://production-url.com/ # Check security headers
  # Toggle feature flag ON, verify app accessible
  # Toggle feature flag OFF, verify app hidden
  ```
  - Monitor logs for errors during flag toggle
  - Verify database performance under expected load
- **Rollback Plan:** Set feature flag to OFF, rollback to previous stable version
- **Feature Flag(s):** ff.potato.no_drink_v1 + toggle to ON + production activation

---

## Current Status
- **Phase 0:** ‚ö†Ô∏è DEPLOYMENT CONFIG NEEDED (see bugs journal 2025-09-01)
- **Phase 1:** üîÑ READY TO START (after Phase 0 deployment fix)
- **Phases 2-5:** üìã PLANNED

## Key Principles
- All functionality gated behind ff.potato.no_drink_v1 feature flag
- Evidence-first approach with testable exit criteria
- Phase-gated development requiring explicit approval
- Rollback plans for every phase
- Production-ready architecture from Phase 0