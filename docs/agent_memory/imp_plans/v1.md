# Implementation Plan v1 - Potato No Drink Tracker

## Overview
Phase-gated development plan for building a simple habit tracking web app where users mark calendar days as "No Drink". All features ship behind feature flag `ff.potato.no_drink_v1` (default OFF).

---

## PHASE 0: Foundation & Database Setup ‚úÖ COMPLETE
- **Goal:** Establish core infrastructure with PostgreSQL schema, basic Express server, and feature flag framework
- **Tasks:**
  - Set up Express.js server with CORS and basic middleware ‚úÖ
  - Configure PostgreSQL connection and create database schema ‚úÖ
  - Implement feature flag system with ff.potato.no_drink_v1 (default OFF) ‚úÖ
  - Create basic health check endpoint ‚úÖ
  - Set up environment configuration ‚úÖ
- **Risks/Assumptions:**
  - PostgreSQL service availability in deployment environment ‚úÖ
  - Feature flag system correctly gates all functionality ‚úÖ
- **Exit Criteria (objective, testable):**
  - Server starts successfully on configured port ‚úÖ
  - Database connection established and schema created ‚úÖ
  - Feature flag returns correct default state (OFF) ‚úÖ
  - Health check endpoint returns 200 status ‚úÖ
  - **UPDATED:** Deployment configuration validated (start scripts, port binding, production readiness) ‚ö†Ô∏è
- **Evidence to Collect:**
  ```sql
  SELECT table_name FROM information_schema.tables WHERE table_schema = 'public';
  SELECT column_name, data_type FROM information_schema.columns WHERE table_name = 'users';
  ```
  ```bash
  curl http://localhost:3000/health
  curl http://localhost:3000/api/feature-flags/ff.potato.no_drink_v1
  ```
- **Rollback Plan:** Remove database tables, stop server process
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + server-wide scope
- **Status:** ‚ö†Ô∏è NEEDS DEPLOYMENT FIX (see bugs journal 2025-09-01)

---

## PHASE 1A: User Model & Registration
- **Goal:** Extend user schema and implement secure user registration
- **Tasks:**
  - Add timezone field to user model in shared/schema.ts
  - Push schema changes to database (npm run db:push)
  - Create user registration endpoint (POST /api/auth/signup)
  - Implement password hashing with bcrypt
  - Add email uniqueness validation
- **Risks/Assumptions:**
  - Database schema migration succeeds without data loss
  - Password hashing performance acceptable
  - Email uniqueness properly enforced by database constraints
- **Exit Criteria (objective, testable):**
  - User can register with email/password/timezone
  - Passwords are hashed (not stored in plaintext)
  - Duplicate emails return 400 error
  - Timezone field is stored correctly
- **Evidence to Collect:**
  ```bash
  curl -X POST http://localhost:3000/api/auth/signup -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"test123","timezone":"America/New_York"}'
  ```
  ```sql
  SELECT email, timezone, password_hash, created_at FROM users WHERE email = 'test@example.com';
  # Verify password_hash != 'test123' (is hashed)
  ```
- **Rollback Plan:** Disable signup endpoint, revert schema changes if needed
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + signup endpoint gated

---

## PHASE 1B: Minimal Frontend for Auth Testing
- **Goal:** Build a simple React UI to test the signup API (Phase 1A)
- üìÅ **Code lives in /client/** ‚Äî helps future devs know where to find the test UI
- **Tasks:**
  - Create a Vite+React frontend in /client
  - Add signup form with email, password, timezone
  - Submit form to POST /api/auth/signup
  - Show success and error messages
  - Include optional toggle for feature flag ff.potato.no_drink_v1
  - Add basic client-side validation
- **Preconditions:**
  - Backend CORS must allow dev client origin (e.g., http://localhost:5173)
- **Risks/Assumptions:**
  - Form is unstyled and dev-only
- **Exit Criteria (objective, testable):**
  - Form submits to POST /api/auth/signup and creates user in DB
  - Form must block invalid input client-side before submission
  - Valid inputs return success message
  - Invalid inputs return error messages
  - Manual test confirms DB entry created
- **Evidence to Collect:**
  - Browser test of form submission
  - Dev tools console logs from POST /api/auth/signup
  - SQL check:
    ```sql
    SELECT email, timezone FROM users ORDER BY created_at DESC LIMIT 1;
    ```
- **Rollback Plan:** Disable frontend dev server, remove test form
- **Feature Flag(s):** None (UI is dev-only)

---

## PHASE 1C: Authentication & Sessions
- **Goal:** Implement secure login with session management
- **Tasks:**
  - Create user login endpoint (POST /api/auth/login)
  - Set up session management with express-session default storage
  - Configure secure session cookies: `HttpOnly`, `Secure`, and `SameSite=Strict` flags
  - Implement session ID regeneration on successful login to prevent fixation
  - Add password verification against hashed passwords
- **Risks/Assumptions:**
  - Session storage mechanism works reliably
  - Session fixation or insecure cookies if security flags are not set correctly
  - Password comparison works correctly with bcrypt
- **Exit Criteria (objective, testable):**
  - User can login with valid credentials
  - Invalid credentials return 401 error
  - Session persists across requests
  - Session cookie includes all security flags (HttpOnly, Secure, SameSite=Strict)
  - Session ID changes after successful login
- **Evidence to Collect:**
  ```bash
  curl -i -X POST http://localhost:3000/api/auth/login -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"test123"}'
  # Verify Set-Cookie includes: HttpOnly; Secure; SameSite=Strict
  curl -X POST http://localhost:3000/api/auth/login -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"wrong"}'
  # Should return 401
  ```
- **Rollback Plan:** Disable login endpoint, clear active user sessions
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + login endpoint gated

---

## PHASE 1D: User Profile & Integration
- **Goal:** Complete authentication flow with user profile access
- **Tasks:**
  - Create user profile endpoint (GET /api/me)
  - Add session-based authentication middleware
  - Implement session validation for protected routes
  - Test complete registration ‚Üí login ‚Üí profile access flow
- **Risks/Assumptions:**
  - Session middleware correctly identifies authenticated users
  - Profile data retrieval performs adequately
- **Exit Criteria (objective, testable):**
  - Authenticated users can access profile data
  - Unauthenticated requests to /api/me return 401
  - Profile returns correct user data (email, timezone, created_at)
  - Complete auth flow works end-to-end
- **Evidence to Collect:**
  ```bash
  # Complete flow test
  curl -X POST http://localhost:3000/api/auth/signup -H "Content-Type: application/json" -d '{"email":"flow@test.com","password":"test123","timezone":"America/New_York"}'
  curl -c cookies.txt -X POST http://localhost:3000/api/auth/login -H "Content-Type: application/json" -d '{"email":"flow@test.com","password":"test123"}'
  curl -b cookies.txt http://localhost:3000/api/me
  curl http://localhost:3000/api/me  # Should return 401
  ```
  ```sql
  SELECT email, timezone, created_at FROM users WHERE email = 'flow@test.com';
  ```
- **Rollback Plan:** Disable profile endpoint, revert authentication middleware
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + profile endpoint gated

---

## PHASE 2: Calendar API & Data Model
- **Goal:** Implement calendar data retrieval and day marking functionality with proper timezone handling
- **Tasks:**
  - Create calendar endpoint (GET /api/calendar?month=2025-06)
  - Implement day marking endpoint (POST /api/days/:yyyy-mm-dd/no-drink)
  - Add timezone-aware date validation (2025-01-01 to today)
  - Implement idempotent marking logic
  - Create event logging for click_events table
  - Add unique constraint enforcement on day_marks
- **Risks/Assumptions:**
  - Timezone calculations work correctly across different user timezones
  - Database constraints prevent duplicate entries
  - Date range validation covers edge cases
- **Exit Criteria (objective, testable):**
  - Calendar API returns correct month data with marked days
  - Day marking creates day_marks entry and click_events log
  - Duplicate marking attempts are no-ops (no duplicate day_marks)
  - Date validation rejects dates before 2025-01-01 or future dates (except today)
  - Timezone-aware "today" calculation works correctly
- **Evidence to Collect:**
  ```bash
  curl -H "Cookie: session_id=..." http://localhost:3000/api/calendar?month=2025-06
  curl -X POST -H "Cookie: session_id=..." http://localhost:3000/api/days/2025-06-15/no-drink
  ```
  ```sql
  SELECT user_id, date, value, updated_at FROM day_marks WHERE user_id = '...';
  SELECT user_id, date, created_at FROM click_events WHERE user_id = '...';
  SELECT COUNT(*) FROM day_marks WHERE user_id = '...' AND date = '2025-06-15';
  ```
- **Rollback Plan:** Disable calendar and marking endpoints, clear test data
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + calendar API gated

---

## PHASE 3: React Frontend & Calendar UI
- **Goal:** Build React frontend with calendar grid, day drawer, and basic user interface
- **Tasks:**
  - Set up React + Vite project structure
  - Create CalendarGrid component with month navigation
  - Implement DayCell component with click handlers
  - Build DayDrawer component with "No Drink" button
  - Add visual indicators for marked days (dots + color)
  - Implement month restriction (2025 only)
  - Add future date disabling (except today)
- **Risks/Assumptions:**
  - Calendar grid renders correctly across different screen sizes
  - Date calculations match backend timezone logic
  - User interactions feel responsive
- **Exit Criteria (objective, testable):**
  - Calendar displays current month with proper navigation
  - Clicking a day opens drawer with correct date
  - Marked days show visual indicators
  - Future dates (except today) are disabled
  - Month navigation restricted to 2025
- **Evidence to Collect:**
  ```bash
  npm run build
  curl http://localhost:3000/ # Should serve React app
  # Browser testing: verify calendar renders, day clicking works
  ```
  - Manual testing: click various dates, verify drawer opens
  - Visual inspection: marked days show dots/color
- **Rollback Plan:** Serve static placeholder page instead of React app
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + frontend feature gated

---

## PHASE 4: Integration & User Experience
- **Goal:** Connect frontend to backend APIs, implement toast notifications, and complete user flow
- **Tasks:**
  - Integrate authentication flow in React
  - Connect calendar component to GET /api/calendar
  - Implement day marking with POST /api/days/:date/no-drink
  - Add toast notifications for success/failure
  - Display last updated timestamp in drawer
  - Add loading states and error handling
  - Implement client-side debouncing
- **Risks/Assumptions:**
  - API integration works seamlessly
  - Error states are handled gracefully
  - User experience feels polished
- **Exit Criteria (objective, testable):**
  - User can complete full flow: register ‚Üí login ‚Üí mark days ‚Üí see visual feedback
  - Toast notifications appear on save success/failure
  - Loading states display during API calls
  - Error conditions show appropriate messages
  - Day marking is debounced to prevent rapid clicks
- **Evidence to Collect:**
  - End-to-end user flow testing
  - Network tab shows correct API calls
  - Database verification of marked days
  ```sql
  SELECT u.email, dm.date, dm.value, dm.updated_at 
  FROM users u JOIN day_marks dm ON u.id = dm.user_id 
  WHERE u.email = 'test@example.com';
  ```
- **Rollback Plan:** Disable frontend API integration, show static calendar
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + complete feature gated

---

## PHASE 5: Production Readiness & Feature Flag Activation
- **Goal:** Prepare for production deployment and enable feature flag for user access
- **Tasks:**
  - Add production environment configuration
  - Implement proper error logging and monitoring
  - Add basic security headers and rate limiting
  - Verify all database constraints and indexes
  - Test feature flag toggle functionality
  - Prepare feature flag activation plan
- **Risks/Assumptions:**
  - Production environment matches development setup
  - Feature flag toggle works without service restart
  - Security measures don't break user experience
- **Exit Criteria (objective, testable):**
  - Application runs stable in production environment
  - Feature flag can be toggled ON/OFF without issues
  - Security headers present in HTTP responses
  - Error logging captures issues appropriately
  - Rate limiting prevents abuse
- **Evidence to Collect:**
  ```bash
  curl -I http://production-url.com/ # Check security headers
  # Toggle feature flag ON, verify app accessible
  # Toggle feature flag OFF, verify app hidden
  ```
  - Monitor logs for errors during flag toggle
  - Verify database performance under expected load
- **Rollback Plan:** Set feature flag to OFF, rollback to previous stable version
- **Feature Flag(s):** ff.potato.no_drink_v1 + toggle to ON + production activation

---

## Current Status
- **Phase 0:** ‚ö†Ô∏è DEPLOYMENT CONFIG NEEDED (see bugs journal 2025-09-01)
- **Phase 1:** üîÑ READY TO START (after Phase 0 deployment fix)
- **Phases 2-5:** üìã PLANNED

## Key Principles
- All functionality gated behind ff.potato.no_drink_v1 feature flag
- Evidence-first approach with testable exit criteria
- Phase-gated development requiring explicit approval
- Rollback plans for every phase
- Production-ready architecture from Phase 0