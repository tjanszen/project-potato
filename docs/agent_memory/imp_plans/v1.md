# Implementation Plan v1 - Potato No Drink Tracker

## Overview
Phase-gated development plan for building a simple habit tracking web app where users mark calendar days as "No Drink". All features ship behind feature flag `ff.potato.no_drink_v1` (default OFF).

---

## PHASE 0: Foundation & Database Setup ‚úÖ COMPLETE
- **Goal:** Establish core infrastructure with PostgreSQL schema, basic Express server, and feature flag framework
- **Tasks:**
  - Set up Express.js server with CORS and basic middleware ‚úÖ
  - Configure PostgreSQL connection and create database schema ‚úÖ
  - Implement feature flag system with ff.potato.no_drink_v1 (default OFF) ‚úÖ
  - Create basic health check endpoint ‚úÖ
  - Set up environment configuration ‚úÖ
- **Risks/Assumptions:**
  - PostgreSQL service availability in deployment environment ‚úÖ
  - Feature flag system correctly gates all functionality ‚úÖ
- **Exit Criteria (objective, testable):**
  - Server starts successfully on configured port ‚úÖ
  - Database connection established and schema created ‚úÖ
  - Feature flag returns correct default state (OFF) ‚úÖ
  - Health check endpoint returns 200 status ‚úÖ
  - **UPDATED:** Deployment configuration validated (start scripts, port binding, production readiness) ‚ö†Ô∏è
- **Evidence to Collect:**
  ```sql
  SELECT table_name FROM information_schema.tables WHERE table_schema = 'public';
  SELECT column_name, data_type FROM information_schema.columns WHERE table_name = 'users';
  ```
  ```bash
  curl http://localhost:3000/health
  curl http://localhost:3000/api/feature-flags/ff.potato.no_drink_v1
  ```
- **Rollback Plan:** Remove database tables, stop server process
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + server-wide scope
- **Status:** ‚ö†Ô∏è NEEDS DEPLOYMENT FIX (see bugs journal 2025-09-01)

---

## PHASE 1A: User Model & Registration
- **Goal:** Extend user schema and implement secure user registration
- **Tasks:**
  - Add timezone field to user model in shared/schema.ts
  - Push schema changes to database (npm run db:push)
  - Create user registration endpoint (POST /api/auth/signup)
  - Implement password hashing with bcrypt
  - Add email uniqueness validation
- **Risks/Assumptions:**
  - Database schema migration succeeds without data loss
  - Password hashing performance acceptable
  - Email uniqueness properly enforced by database constraints
- **Exit Criteria (objective, testable):**
  - User can register with email/password/timezone
  - Passwords are hashed (not stored in plaintext)
  - Duplicate emails return 400 error
  - Timezone field is stored correctly
- **Evidence to Collect:**
  ```bash
  curl -X POST http://localhost:3000/api/auth/signup -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"test123","timezone":"America/New_York"}'
  ```
  ```sql
  SELECT email, timezone, password_hash, created_at FROM users WHERE email = 'test@example.com';
  # Verify password_hash != 'test123' (is hashed)
  ```
- **Rollback Plan:** Disable signup endpoint, revert schema changes if needed
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + signup endpoint gated

---

## PHASE 1B: Minimal Frontend for Auth Testing
- **Goal:** Build a simple React UI to test the signup API (Phase 1A)
- üìÅ **Code lives in /client/** ‚Äî helps future devs know where to find the test UI
- **Tasks:**
  - Create a Vite+React frontend in /client
  - Add signup form with email, password, timezone
  - Submit form to POST /api/auth/signup
  - Show success and error messages
  - Include optional toggle for feature flag ff.potato.no_drink_v1
  - Add basic client-side validation
- **Preconditions:**
  - Backend CORS must allow dev client origin (e.g., http://localhost:5173)
- **Risks/Assumptions:**
  - Form is unstyled and dev-only
- **Exit Criteria (objective, testable):**
  - Form submits to POST /api/auth/signup and creates user in DB
  - Form must block invalid input client-side before submission
  - Valid inputs return success message
  - Invalid inputs return error messages
  - Manual test confirms DB entry created
- **Evidence to Collect:**
  - Browser test of form submission
  - Dev tools console logs from POST /api/auth/signup
  - SQL check:
    ```sql
    SELECT email, timezone FROM users ORDER BY created_at DESC LIMIT 1;
    ```
- **Rollback Plan:** Disable frontend dev server, remove test form
- **Feature Flag(s):** None (UI is dev-only)

---

## PHASE 1C: Authentication & Sessions
- **Goal:** Implement secure login with session management
- **Tasks:**
  - Create user login endpoint (POST /api/auth/login)
  - Set up session management with express-session default storage
  - Configure secure session cookies: `HttpOnly`, `Secure`, and `SameSite=Strict` flags
  - Implement session ID regeneration on successful login to prevent fixation
  - Add password verification against hashed passwords
- **Risks/Assumptions:**
  - Session storage mechanism works reliably
  - Session fixation or insecure cookies if security flags are not set correctly
  - Password comparison works correctly with bcrypt
- **Exit Criteria (objective, testable):**
  - User can login with valid credentials
  - Invalid credentials return 401 error
  - Session persists across requests
  - Session cookie includes all security flags (HttpOnly, Secure, SameSite=Strict)
  - Session ID changes after successful login
- **Evidence to Collect:**
  ```bash
  curl -i -X POST http://localhost:3000/api/auth/login -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"test123"}'
  # Verify Set-Cookie includes: HttpOnly; Secure; SameSite=Strict
  curl -X POST http://localhost:3000/api/auth/login -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"wrong"}'
  # Should return 401
  ```
- **Rollback Plan:** Disable login endpoint, clear active user sessions
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + login endpoint gated

---

## PHASE 1D: User Profile & Integration
- **Goal:** Complete authentication flow with user profile access
- **Tasks:**
  - Create user profile endpoint (GET /api/me)
  - Add session-based authentication middleware
  - Implement session validation for protected routes
  - Test complete registration ‚Üí login ‚Üí profile access flow
- **Risks/Assumptions:**
  - Session middleware correctly identifies authenticated users
  - Profile data retrieval performs adequately
- **Exit Criteria (objective, testable):**
  - Authenticated users can access profile data
  - Unauthenticated requests to /api/me return 401
  - Profile returns correct user data (email, timezone, created_at)
  - Complete auth flow works end-to-end
- **Evidence to Collect:**
  ```bash
  # Complete flow test
  curl -X POST http://localhost:3000/api/auth/signup -H "Content-Type: application/json" -d '{"email":"flow@test.com","password":"test123","timezone":"America/New_York"}'
  curl -c cookies.txt -X POST http://localhost:3000/api/auth/login -H "Content-Type: application/json" -d '{"email":"flow@test.com","password":"test123"}'
  curl -b cookies.txt http://localhost:3000/api/me
  curl http://localhost:3000/api/me  # Should return 401
  ```
  ```sql
  SELECT email, timezone, created_at FROM users WHERE email = 'flow@test.com';
  ```
- **Rollback Plan:** Disable profile endpoint, revert authentication middleware
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + profile endpoint gated

---

## PHASE 2A: Calendar Retrieval API
- **Goal:** Implement calendar data retrieval with proper month filtering and user authentication
- **Tasks:**
  - Create calendar endpoint (GET /api/calendar?month=2025-06)
  - Add authentication middleware to protect calendar endpoint
  - Implement month-based day_marks retrieval from database
  - Return JSON format with date array and marked status
  - Add basic input validation for month parameter format
- **Risks/Assumptions:**
  - Calendar query performance acceptable with user-based filtering
  - Month parameter format correctly validated (YYYY-MM)
  - Authentication middleware correctly identifies users
- **Exit Criteria (objective, testable):**
  - Calendar API requires valid authentication (returns 401 if not logged in)
  - Calendar API returns correct month data structure
  - API correctly filters day_marks by authenticated user
  - Month parameter validation rejects invalid formats
- **Evidence to Collect:**
  ```bash
  curl -b cookies.txt http://localhost:3000/api/calendar?month=2025-06
  curl http://localhost:3000/api/calendar?month=2025-06  # Should return 401
  curl -b cookies.txt http://localhost:3000/api/calendar?month=invalid  # Should return 400
  ```
  ```sql
  SELECT user_id, date, value, updated_at FROM day_marks WHERE user_id = 'test-user-id';
  ```
- **Rollback Plan:** Disable calendar endpoint, revert authentication requirements
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + calendar endpoint gated

---

## PHASE 2B: Day Marking API
- **Goal:** Implement day marking endpoint with basic database persistence
- **Tasks:**
  - Create day marking endpoint (POST /api/days/:yyyy-mm-dd/no-drink)
  - Add date parameter parsing and basic validation
  - Implement day_marks table insertion with user_id
  - Add authentication middleware to protect marking endpoint
  - Return success/error responses with appropriate status codes
- **Risks/Assumptions:**
  - Date parsing works correctly for various input formats
  - Database insertion handles user_id association properly
  - API response format meets client expectations
- **Exit Criteria (objective, testable):**
  - Day marking API requires valid authentication (returns 401 if not logged in)
  - Valid date marking creates entry in day_marks table
  - API returns success response with created data
  - Invalid date format returns 400 error
- **Evidence to Collect:**
  ```bash
  curl -X POST -b cookies.txt http://localhost:3000/api/days/2025-06-15/no-drink
  curl -X POST http://localhost:3000/api/days/2025-06-15/no-drink  # Should return 401
  curl -X POST -b cookies.txt http://localhost:3000/api/days/invalid-date/no-drink  # Should return 400
  ```
  ```sql
  SELECT user_id, date, value, created_at FROM day_marks WHERE date = '2025-06-15';
  ```
- **Rollback Plan:** Disable day marking endpoint, remove test day_marks entries
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + day marking endpoint gated

---

## PHASE 2C: Timezone-Aware Validation
- **Goal:** Implement proper timezone-aware date validation and "today" calculation
- **Tasks:**
  - Add timezone-aware date validation (2025-01-01 to today in user's timezone)
  - Implement user timezone retrieval from database
  - Create date boundary validation logic
  - Add "today" calculation based on user's timezone
  - Reject future dates except "today" in user's timezone
- **Risks/Assumptions:**
  - Timezone calculations work correctly across different user timezones
  - Date boundary validation covers edge cases (leap years, month boundaries)
  - User timezone data is always available and valid
- **Exit Criteria (objective, testable):**
  - Date validation rejects dates before 2025-01-01 in user's timezone
  - Date validation rejects future dates (except today) in user's timezone
  - "Today" calculation works correctly for different user timezones
  - Validation errors return appropriate error messages
- **Evidence to Collect:**
  ```bash
  # Test with user in America/New_York timezone
  curl -X POST -b cookies.txt http://localhost:3000/api/days/2024-12-31/no-drink  # Should reject
  curl -X POST -b cookies.txt http://localhost:3000/api/days/2025-12-31/no-drink  # Should reject if future
  curl -X POST -b cookies.txt http://localhost:3000/api/days/$(date +%Y-%m-%d)/no-drink  # Should work
  ```
  ```sql
  SELECT email, timezone FROM users WHERE id = 'test-user-id';
  ```
- **Rollback Plan:** Disable timezone validation, use simple date checks
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + timezone validation gated

---

## PHASE 2D: Idempotency & Constraints
- **Goal:** Implement idempotent day marking with proper database constraints
- **Tasks:**
  - Add unique constraint on (user_id, date) in day_marks table
  - Implement ON CONFLICT DO UPDATE logic for idempotent marking
  - Handle duplicate marking attempts gracefully (return existing record)
  - Add database constraint enforcement
  - Test edge cases for concurrent marking attempts
- **Risks/Assumptions:**
  - Database constraints prevent duplicate entries reliably
  - ON CONFLICT logic works correctly with PostgreSQL
  - Concurrent requests don't cause race conditions
- **Exit Criteria (objective, testable):**
  - Multiple marking attempts for same day are no-ops (no duplicate day_marks)
  - Database enforces unique constraint on (user_id, date)
  - Duplicate attempts return success with existing data
  - Concurrent marking attempts handled gracefully
- **Evidence to Collect:**
  ```bash
  # Mark same day multiple times
  curl -X POST -b cookies.txt http://localhost:3000/api/days/2025-06-15/no-drink
  curl -X POST -b cookies.txt http://localhost:3000/api/days/2025-06-15/no-drink
  curl -X POST -b cookies.txt http://localhost:3000/api/days/2025-06-15/no-drink
  ```
  ```sql
  SELECT COUNT(*) as count FROM day_marks WHERE user_id = 'test-user-id' AND date = '2025-06-15';
  -- Should return count = 1
  ```
- **Rollback Plan:** Remove unique constraints, allow duplicate entries temporarily
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + idempotency constraints gated

---

## PHASE 2E: Event Logging
- **Goal:** Implement comprehensive event logging for audit trail and analytics
- **Tasks:**
  - Create event logging for click_events table on every marking attempt
  - Log both successful and duplicate marking attempts
  - Add timestamp and user context to event logs
  - Implement event logging middleware
  - Add event retrieval for debugging/analytics
- **Risks/Assumptions:**
  - Event logging doesn't significantly impact performance
  - click_events table handles high volume appropriately
  - Event data provides useful audit trail
- **Exit Criteria (objective, testable):**
  - Every day marking attempt creates entry in click_events table
  - Event logs include user_id, date, timestamp, and action type
  - Both successful and duplicate attempts are logged
  - Event logging doesn't block day marking on failure
- **Evidence to Collect:**
  ```bash
  # Make several marking attempts
  curl -X POST -b cookies.txt http://localhost:3000/api/days/2025-06-15/no-drink
  curl -X POST -b cookies.txt http://localhost:3000/api/days/2025-06-16/no-drink
  ```
  ```sql
  SELECT user_id, date, action, created_at FROM click_events WHERE user_id = 'test-user-id' ORDER BY created_at DESC;
  SELECT COUNT(*) as event_count FROM click_events WHERE user_id = 'test-user-id';
  SELECT COUNT(*) as mark_count FROM day_marks WHERE user_id = 'test-user-id';
  ```
- **Rollback Plan:** Disable event logging, clear test click_events entries
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + event logging gated

---

## PHASE 3A: Frontend Project Setup
- **Goal:** Set up React + Vite frontend infrastructure with proper development workflow
- **Tasks:**
  - Set up React + Vite project structure in /client directory
  - Configure TypeScript and essential development dependencies
  - Set up routing with wouter for single-page navigation
  - Configure API client with proper CORS and authentication
  - Add development scripts and build configuration
  - Implement basic error boundaries and loading states
- **Risks/Assumptions:**
  - Vite build configuration works with existing Express server
  - TypeScript compilation succeeds without conflicts
  - Development server integrates properly with backend APIs
- **Exit Criteria (objective, testable):**
  - Frontend project builds successfully with npm run build
  - Development server starts without errors
  - API client can connect to backend endpoints
  - TypeScript compilation passes without errors
  - Basic routing navigation works
- **Evidence to Collect:**
  ```bash
  cd /client && npm run build
  cd /client && npm run dev  # Should start on port 5173
  curl http://localhost:5173/  # Should serve React app
  # Browser test: verify app loads without console errors
  ```
  - Network tab shows successful API connection attempts
  - TypeScript compiler shows no errors
- **Rollback Plan:** Serve static HTML page, disable React frontend
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + frontend project gated

---

## PHASE 3B: Calendar Grid & Navigation
- **Goal:** Create monthly calendar grid component with month-to-month navigation
- **Tasks:**
  - Build CalendarGrid component with 7x6 grid layout
  - Implement month header with current month/year display
  - Add previous/next month navigation buttons
  - Create date calculation logic for proper calendar layout
  - Add month restriction to 2025 only (disable other years)
  - Style calendar grid for responsive design
- **Risks/Assumptions:**
  - Date calculations work correctly across month boundaries
  - Calendar layout renders properly on different screen sizes
  - Month restriction logic prevents navigation outside 2025
- **Exit Criteria (objective, testable):**
  - Calendar displays current month with correct date layout
  - Previous/next buttons navigate between months correctly
  - Navigation is restricted to 2025 (Jan-Dec only)
  - Calendar grid is responsive and visually formatted
  - Date cells display correct day numbers
- **Evidence to Collect:**
  ```bash
  # Browser testing required
  # Navigate to January 2025, verify no previous month button
  # Navigate to December 2025, verify no next month button
  # Test calendar grid on mobile and desktop viewports
  ```
  - Manual testing: verify month navigation boundaries
  - Visual inspection: calendar grid layout and responsiveness
  - Console verification: no date calculation errors
- **Rollback Plan:** Show static calendar placeholder, disable navigation
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + calendar grid gated

---

## PHASE 3C: DayCell Component & Interaction
- **Goal:** Implement individual day cells with click handlers and date selection
- **Tasks:**
  - Create DayCell component for individual calendar dates
  - Add click handlers for day selection
  - Implement date state management (selected day)
  - Add hover effects and interactive feedback
  - Handle edge cases (empty cells, month boundaries)
  - Pass selected date to parent components
- **Risks/Assumptions:**
  - Click handlers respond quickly without lag
  - Date selection state management works correctly
  - Component re-renders efficiently on state changes
- **Exit Criteria (objective, testable):**
  - Clicking a day cell selects that date
  - Selected date is properly stored in component state
  - Hover effects provide visual feedback
  - Empty cells (outside current month) are non-interactive
  - Date selection triggers parent component updates
- **Evidence to Collect:**
  ```bash
  # Browser testing required - no curl equivalent
  # Click various dates, verify selection state changes
  # Test hover effects on interactive cells
  # Verify empty cells don't respond to clicks
  ```
  - Manual testing: click different dates, verify selection
  - Developer tools: verify state updates in React DevTools
  - Visual inspection: hover and selection styling
- **Rollback Plan:** Disable click handlers, show static calendar cells
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + day selection gated

---

## PHASE 3D: DayDrawer & "No Drink" Button
- **Goal:** Build sliding drawer component with day marking functionality
- **Tasks:**
  - Create DayDrawer component with slide-in animation
  - Display selected date in drawer header
  - Add "No Drink" button with click handler
  - Implement drawer open/close functionality
  - Connect drawer to day marking API (POST /api/days/:date/no-drink)
  - Add loading states and success/error feedback
- **Risks/Assumptions:**
  - Drawer animation performs smoothly
  - API integration works reliably
  - User feedback mechanisms are clear
- **Exit Criteria (objective, testable):**
  - Drawer opens when day is selected
  - Drawer displays correct selected date
  - "No Drink" button sends API request
  - API success/failure shows appropriate feedback
  - Drawer can be closed by user interaction
- **Evidence to Collect:**
  ```bash
  # API testing can be verified with network tab
  # POST /api/days/2025-06-15/no-drink should be sent
  ```
  - Manual testing: open drawer, click "No Drink" button
  - Network tab: verify API calls are made correctly
  - Database verification: marked days appear in database
  ```sql
  SELECT date, value, updated_at FROM day_marks WHERE user_id = 'test-user-id' ORDER BY updated_at DESC;
  ```
- **Rollback Plan:** Disable drawer functionality, show marking status inline
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + day marking drawer gated

---

## PHASE 3E: Visual Indicators & Restrictions
- **Goal:** Add visual feedback for marked days and enforce date restrictions
- **Tasks:**
  - Add visual indicators (dots/colors) for marked days
  - Implement future date disabling (except today in user timezone)
  - Style disabled dates with different appearance
  - Connect visual indicators to calendar API data
  - Add loading states for calendar data fetching
  - Implement refresh functionality to update indicators
- **Risks/Assumptions:**
  - Visual indicators are clearly visible and intuitive
  - Date restrictions match backend timezone logic exactly
  - Calendar data loading doesn't impact user experience
- **Exit Criteria (objective, testable):**
  - Marked days display visual indicators (dots, colors)
  - Future dates (except today) are visually disabled and non-clickable
  - Calendar loads marked days from API on page load
  - Visual indicators update immediately after marking
  - Date restrictions match user's timezone settings
- **Evidence to Collect:**
  ```bash
  # GET /api/calendar?month=2025-06 should return marked dates
  curl -b cookies.txt http://localhost:3000/api/calendar?month=2025-06
  ```
  - Manual testing: verify marked days show indicators
  - Visual inspection: disabled future dates appear different
  - API verification: calendar loads existing marked days
  - Timezone testing: verify today calculation matches user timezone
  ```sql
  SELECT date, value FROM day_marks WHERE user_id = 'test-user-id';
  ```
- **Rollback Plan:** Remove visual indicators, disable date restrictions
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + visual indicators gated

---

## PHASE 4A: Authentication Integration
- **Goal:** Connect React frontend to authentication APIs for complete login/signup flow
- **Tasks:**
  - Create React login and signup forms with proper validation
  - Integrate with POST /api/auth/signup and POST /api/auth/login endpoints
  - Implement session management and authentication state
  - Add authentication guards for protected components
  - Handle authentication errors and session expiration
  - Store authentication state in React context or state management
- **Risks/Assumptions:**
  - Session cookies work correctly between frontend and backend
  - Authentication state persists across browser refreshes
  - Error handling covers all authentication failure scenarios
- **Exit Criteria (objective, testable):**
  - Users can register new accounts through React forms
  - Users can login with existing credentials through React forms
  - Authentication state persists across page refreshes
  - Protected routes redirect to login when unauthenticated
  - Authentication errors display appropriate user messages
- **Evidence to Collect:**
  ```bash
  # Test authentication flow through browser
  # Network tab should show successful POST requests
  # Check browser storage for session cookies
  ```
  - Manual testing: complete signup and login flows
  - Browser DevTools: verify authentication API calls
  - State verification: authentication persists across refresh
  ```sql
  SELECT email, timezone, created_at FROM users ORDER BY created_at DESC LIMIT 5;
  ```
- **Rollback Plan:** Disable React authentication, redirect to static login page
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + frontend authentication gated

---

## PHASE 4B: Calendar API Integration
- **Goal:** Connect React calendar component to backend calendar data API
- **Tasks:**
  - Integrate calendar grid with GET /api/calendar endpoint
  - Implement month-based data fetching and caching
  - Add loading states during calendar data retrieval
  - Handle calendar API errors gracefully
  - Implement automatic data refresh on month navigation
  - Display marked days using data from calendar API
- **Risks/Assumptions:**
  - Calendar API responds quickly enough for good UX
  - Data format from API matches frontend expectations exactly
  - Month navigation doesn't cause excessive API calls
- **Exit Criteria (objective, testable):**
  - Calendar loads marked days from API on initial page load
  - Month navigation triggers new API calls automatically
  - Loading indicators display during calendar data fetching
  - API errors show user-friendly error messages
  - Marked days from database display visual indicators correctly
- **Evidence to Collect:**
  ```bash
  curl -b cookies.txt http://localhost:3000/api/calendar?month=2025-06
  # Should return: {"month":"2025-06","markedDates":["2025-06-01","2025-06-15"],"count":2}
  ```
  - Network tab: verify GET /api/calendar calls on month navigation
  - Manual testing: marked days appear as visual indicators
  - Error testing: verify handling of API failures
  ```sql
  SELECT user_id, date, value FROM day_marks WHERE date >= '2025-06-01' AND date < '2025-07-01';
  ```
- **Rollback Plan:** Show static calendar without API integration
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + calendar API integration gated

---

## PHASE 4C: Day Marking Integration
- **Goal:** Connect day marking button to backend API with proper state updates
- **Tasks:**
  - Integrate "No Drink" button with POST /api/days/:date/no-drink endpoint
  - Update calendar visual indicators immediately after successful marking
  - Handle day marking errors and display appropriate feedback
  - Implement optimistic updates for better perceived performance
  - Add confirmation states and loading indicators for marking actions
  - Ensure marked days persist correctly across calendar navigation
- **Risks/Assumptions:**
  - Day marking API calls complete quickly enough for good UX
  - Optimistic updates don't cause inconsistent state
  - Network failures during marking are handled gracefully
- **Exit Criteria (objective, testable):**
  - "No Drink" button sends correct API request when clicked
  - Calendar visual indicators update immediately after successful marking
  - Day marking errors display clear error messages to user
  - Optimistic updates revert correctly on API failure
  - Marked days remain visible after month navigation and return
- **Evidence to Collect:**
  ```bash
  # Network tab should show POST /api/days/2025-06-15/no-drink calls
  # API should return: {"message":"Day marked successfully","data":{"date":"2025-06-15","value":true}}
  ```
  - Manual testing: click "No Drink" button, verify immediate visual update
  - Error testing: verify handling of network failures during marking
  - State testing: marked days persist across month navigation
  ```sql
  SELECT date, value, updated_at FROM day_marks WHERE user_id = 'test-user-id' ORDER BY updated_at DESC LIMIT 10;
  ```
- **Rollback Plan:** Disable day marking API calls, show static marking interface
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + day marking integration gated

---

## PHASE 4D: User Feedback & Notifications
- **Goal:** Implement comprehensive user feedback system with toast notifications
- **Tasks:**
  - Add toast notification system for success and error messages
  - Display confirmation messages after successful day marking
  - Show clear error messages for all failure scenarios
  - Add loading indicators for all API operations
  - Implement last updated timestamps in day drawer
  - Create consistent feedback patterns across all user actions
- **Risks/Assumptions:**
  - Toast notifications are visible and don't interfere with user workflow
  - Message content is clear and actionable for users
  - Notification timing feels natural and not overwhelming
- **Exit Criteria (objective, testable):**
  - Toast notifications appear for successful day marking actions
  - Error toasts display for network failures and API errors
  - Loading indicators show during all API operations
  - Last updated timestamp displays in day drawer after marking
  - All user feedback messages are clear and actionable
- **Evidence to Collect:**
  ```bash
  # Test various scenarios to trigger different feedback messages
  # Successful marking, network errors, authentication failures
  ```
  - Manual testing: verify toast notifications for success/error scenarios
  - UX testing: ensure feedback messages are clear and helpful
  - Timing testing: notifications don't overwhelm or persist too long
  - Visual testing: loading indicators appear during API calls
- **Rollback Plan:** Remove toast notifications, show simple inline feedback
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + user feedback system gated

---

## PHASE 4E: UX Polish & Debouncing
- **Goal:** Add final UX improvements including debouncing and performance optimizations
- **Tasks:**
  - Implement click debouncing to prevent rapid/duplicate day marking
  - Optimize calendar rendering performance for large date ranges
  - Implement proper focus management in drawer component
- **Risks/Assumptions:**
  - Debouncing doesn't make the interface feel unresponsive
  - Performance optimizations don't introduce new bugs
- **Exit Criteria (objective, testable):**
  - Rapid clicking on "No Drink" button is properly debounced
  - Calendar navigation feels responsive even with many marked days
  - Focus management keeps proper tab order in drawer
- **Evidence to Collect:**
  ```bash
  # Performance testing: rapid clicks should be debounced
  ```
  - Manual testing: rapid clicking is debounced correctly
  - Performance testing: calendar remains responsive with many marked days
  - Focus testing: tab order remains logical in drawer component
  ```sql
  SELECT COUNT(*) as total_marks FROM day_marks; -- Verify no duplicate marks from rapid clicking
  ```
- **Rollback Plan:** Disable advanced UX features, keep basic functionality
- **Feature Flag(s):** ff.potato.no_drink_v1 + default OFF + UX polish features gated

---

## PHASE 5A: Production Environment Setup
- **Goal:** Configure application for production deployment with proper environment variables and build optimization
- **Tasks:**
  - Set up production environment variables (PORT, NODE_ENV, DATABASE_URL)
  - Migrate feature flag management to Replit Secrets
  - Define Secret Name: FF_POTATO_NO_DRINK_V1 with values "true"/"false"
  - Modify feature-flag service to read from process.env.FF_POTATO_NO_DRINK_V1 with default false
  - Configure production build process for frontend (npm run build)
  - Set up static file serving for built frontend assets
  - Verify production database connection and schema
  - Test production deployment process and health checks
  - Configure proper logging levels for production
- **Risks/Assumptions:**
  - Production environment variables are correctly configured
  - Build process generates optimized assets without errors
  - Database connectivity works in production environment
  - Static file serving doesn't conflict with API routes
- **Exit Criteria (objective, testable):**
  - Application starts successfully with NODE_ENV=production
  - Frontend build process completes without errors
  - Production health check returns 200 status
  - Database connection works with production credentials
  - Static files serve correctly from build directory
  - Feature flag state persists across application restarts
- **Evidence to Collect:**
  ```bash
  NODE_ENV=production npm start
  curl http://production-url.com/health
  curl http://production-url.com/ # Should serve built frontend
  npm run build # Should complete without errors
  echo $FF_POTATO_NO_DRINK_V1 && curl http://production-url.com/api/feature-flags/ff.potato.no_drink_v1 # Should show consistent values
  ```
  ```sql
  SELECT table_name FROM information_schema.tables WHERE table_schema = 'public';
  ```
- **Rollback Plan:** Revert to development configuration, disable production environment
- **Feature Flag(s):** FF_POTATO_NO_DRINK_V1 (Replit Secret) + default OFF + production environment gated

---

## PHASE 5B: Security & Stability Hardening
- **Goal:** Implement production-grade security headers, rate limiting, and stability measures
- **Tasks:**
  - Add security headers (HSTS, Content Security Policy, X-Frame-Options)
  - Implement rate limiting for API endpoints
  - Add request validation and sanitization middleware
  - Configure secure session settings for production
  - Add basic DDoS protection and request throttling
  - Verify HTTPS configuration and redirect HTTP to HTTPS
- **Risks/Assumptions:**
  - Security headers don't break legitimate user interactions
  - Rate limiting thresholds allow normal usage patterns
  - Session security doesn't interfere with user experience
  - HTTPS certificates are properly configured
- **Exit Criteria (objective, testable):**
  - Security headers present in all HTTP responses
  - Rate limiting blocks excessive requests (>100/min per IP)
  - Invalid requests return appropriate 400/422 errors
  - Sessions use secure flags (HttpOnly, Secure, SameSite)
  - HTTPS redirect works for all HTTP requests
- **Evidence to Collect:**
  ```bash
  curl -I http://production-url.com/ # Check security headers
  # Test rate limiting with rapid requests
  for i in {1..105}; do curl -s -o /dev/null -w "%{http_code}\n" http://production-url.com/api/health; done
  curl -k http://production-url.com/ # Should redirect to HTTPS
  ```
  - Verify security headers: HSTS, CSP, X-Frame-Options present
  - Test session cookie flags in browser developer tools
- **Rollback Plan:** Disable security middleware, revert to development security settings
- **Feature Flag(s):** FF_POTATO_NO_DRINK_V1 (Replit Secret) + default OFF + security hardening gated

---

## PHASE 5C: Monitoring & Logging
- **Goal:** Implement comprehensive logging, error tracking, and basic monitoring for production operations
- **Tasks:**
  - Set up structured logging with JSON format for production
  - Implement error logging for all API endpoints and database operations
  - Add request/response logging with correlation IDs
  - Create basic health metrics endpoint (/api/metrics)
  - Set up log rotation and retention policies
  - Add performance monitoring for critical endpoints
- **Risks/Assumptions:**
  - Logging doesn't significantly impact application performance
  - Log volume is manageable within production constraints
  - Error logging captures useful debugging information
  - Metrics collection doesn't expose sensitive data
- **Exit Criteria (objective, testable):**
  - All errors logged with stack traces and context
  - Request logs include method, path, status code, response time
  - Health metrics endpoint returns system status
  - Log files rotate properly and don't fill disk space
  - Performance metrics show response times under 500ms
- **Evidence to Collect:**
  ```bash
  curl http://production-url.com/api/metrics
  # Should return: {"status":"healthy","uptime":12345,"requests":1000}
  tail -f /var/log/app.log # Verify structured logging
  # Trigger error conditions, verify error logging
  ```
  - Monitor log files for proper JSON structure
  - Verify error scenarios generate appropriate log entries
  - Check log rotation works after file size limits
- **Rollback Plan:** Disable detailed logging, revert to basic console logging
- **Feature Flag(s):** FF_POTATO_NO_DRINK_V1 (Replit Secret) + default OFF + monitoring logging gated

---

## PHASE 5D: Feature Flag Final Validation
- **Goal:** Thoroughly test feature flag toggle functionality and prepare activation procedures
- **Tasks:**
  - Test feature flag toggle from OFF to ON state by changing Replit Secret
  - Verify all gated functionality activates correctly
  - Test feature flag toggle from ON to OFF state (emergency disable) via Replit Secret
  - Validate flag state persistence across application restarts
  - Create feature flag activation checklist and procedures for Replit Secrets
  - Test flag toggling via Replit Secrets UI
- **Risks/Assumptions:**
  - Feature flag toggle works reliably without service disruption
  - All gated features activate simultaneously and correctly
  - Emergency disable (OFF) works quickly when needed
  - Flag state persists correctly across application restarts
  - Secret-based flags may require restart if env not hot-reloaded
- **Exit Criteria (objective, testable):**
  - Feature flag can be toggled ON via Replit Secrets and takes effect
  - All authentication, calendar, and marking features work when flag is ON
  - Feature flag can be toggled OFF immediately (emergency disable) via Replit Secrets
  - Application shows appropriate "feature not available" when flag is OFF
  - Flag state persists correctly after application restart
  - Flag toggle via Replit Secrets takes effect within 5 seconds of restart
- **Evidence to Collect:**
  ```bash
  # Test flag toggle ON via Replit Secret (set FF_POTATO_NO_DRINK_V1="true")
  echo $FF_POTATO_NO_DRINK_V1  # Should show "true"
  curl http://production-url.com/api/feature-flags/ff.potato.no_drink_v1
  # Should return: {"name":"ff.potato.no_drink_v1","enabled":true}
  
  # Test application functionality
  curl -X POST http://production-url.com/api/auth/signup -H "Content-Type: application/json" -d '{"email":"test@prod.com","password":"test123","timezone":"America/New_York"}'
  
  # Test flag toggle OFF via Replit Secret (set FF_POTATO_NO_DRINK_V1="false")
  echo $FF_POTATO_NO_DRINK_V1  # Should show "false" after restart
  ```
  - Verify all features become accessible when Replit Secret is "true"
  - Verify all features become inaccessible when Replit Secret is "false"
  - Confirm flag state persists after application restart
- **Rollback Plan:** Set Replit Secret FF_POTATO_NO_DRINK_V1 to "false" immediately, restart if needed
- **Feature Flag(s):** FF_POTATO_NO_DRINK_V1 (Replit Secret) + toggle testing + activation readiness validation

---

## PHASE 5E: Production Activation
- **Goal:** Activate feature flag in production and monitor initial user interactions
- **Tasks:**
  - Execute feature flag activation in production environment
  - Monitor application performance and error rates post-activation
  - Verify user registration and authentication flows work correctly
  - Monitor database performance under real user load
  - Track initial user engagement and feature usage
  - Prepare immediate rollback procedures if issues arise
- **Risks/Assumptions:**
  - Production activation doesn't cause performance degradation
  - Initial user load is manageable within current infrastructure
  - No critical bugs surface during first user interactions
  - Database can handle concurrent user operations
- **Exit Criteria (objective, testable):**
  - Feature flag successfully activated (ff.potato.no_drink_v1 = ON)
  - Application accessible to users without errors
  - User registration and login flows complete successfully
  - Day marking functionality works for real users
  - No critical errors in production logs for 1 hour post-activation
  - Application response times remain under 1 second
- **Evidence to Collect:**
  ```bash
  # Verify flag activation
  curl http://production-url.com/api/feature-flags/ff.potato.no_drink_v1
  # Should return: {"name":"ff.potato.no_drink_v1","enabled":true}
  
  # Monitor application health
  curl http://production-url.com/api/health
  curl http://production-url.com/api/metrics
  
  # Test user flows
  curl -X POST http://production-url.com/api/auth/signup -H "Content-Type: application/json" -d '{"email":"real@user.com","password":"secure123","timezone":"America/New_York"}'
  ```
  ```sql
  SELECT COUNT(*) as total_users FROM users;
  SELECT COUNT(*) as total_marks FROM day_marks;
  SELECT COUNT(*) as error_events FROM click_events WHERE created_at > NOW() - INTERVAL '1 hour';
  ```
  - Monitor application logs for error patterns
  - Track user registration and engagement metrics
  - Verify database performance under real load
- **Rollback Plan:** Immediately set Replit Secret FF_POTATO_NO_DRINK_V1 to "false", restart application, notify users of temporary maintenance
- **Feature Flag(s):** FF_POTATO_NO_DRINK_V1 (Replit Secret) + "true" + production active + user accessible

---

## Current Status
- **Phase 0:** ‚ö†Ô∏è DEPLOYMENT CONFIG NEEDED (see bugs journal 2025-09-01)
- **Phase 1:** üîÑ READY TO START (after Phase 0 deployment fix)
- **Phases 2-5:** üìã PLANNED

## Key Principles
- All functionality gated behind ff.potato.no_drink_v1 feature flag
- Evidence-first approach with testable exit criteria
- Phase-gated development requiring explicit approval
- Rollback plans for every phase
- Production-ready architecture from Phase 0